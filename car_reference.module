<?php

/**
 * @file
 * Main file for Car reference field module.
 */

/**
 * Implements hook_menu().
 */
function car_reference_menu() {
  $items = array();

  $items['car_reference/autocomplete'] = array(
    'title' => 'Autocomplete Car Reference',
    'page callback' => 'car_reference_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'car_reference.pages.inc',
  );

  $items['car_reference/vocabulary_fields/%'] = array(
    'title' => '',
    'page callback' => 'car_reference_vocabulary_fields',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'car_reference.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_views_api().
 */
function car_reference_views_api() {
  return array("version" => "3.0");
}

/**
 * Implements hook_field_info().
 */
function car_reference_field_info() {
  return array(
    'car_reference' => array(
      'label' => t('Car reference'),
      'description' => t('This field stores a reference to a make, model and edition taxonomy term.'),
      'default_widget' => 'car_reference_tids',
      'default_formatter' => 'car_reference_link',
      'settings' => array(
        'allowed_values' => array(
          'make_vocabulary' => array(
            'vocabulary' => 'make',
            'parent' => '0',
          ),
          'model_vocabulary' => array(
            'vocabulary' => 'model',
            'ref_field_name' => '',
            'parent' => '0',
          ),
          'edition_vocabulary' => array(
            'vocabulary' => 'edition',
            'ref_field_name' => '',
            'parent' => '0',
          ),
        ),
      ),
      'instance_settings' => array(
        // Which vocabs to return result from, for autocomplete widget.
        'choose_from' => array(
          'make' => 'make',
          'model' => 'model',
          'edition' => 'edition',
        ),
      ),
      // Support hook_entity_property_info() from contrib "Entity API".
      'property_type' => 'taxonomy_term',
    ),
  );
}

/**
 * Implements hook_field_settings_form().
 */
function car_reference_field_settings_form($field, $instance, $has_data) {
  // Get proper values for 'allowed_values_function', which is a core setting.
  $vocabularies = taxonomy_get_vocabularies();
  $options = array();
  foreach ($vocabularies as $vocabulary) {
    $options[$vocabulary->machine_name] = $vocabulary->name;
  }
  $form['allowed_values'] = array(
    '#tree' => TRUE,
    '#attached' => array(
      'js' => array(
        'car_reference-field-visibility' => drupal_get_path('module', 'car_reference') . '/car_reference.admin.js',
      ),
    ),
  );

  // Get all the vocabularies fields for initial push,
  // as they need to be here for validation purpose.
  $vocabulary_fields = field_info_instances('taxonomy_term');
  $taxonomy_fields_options = array();
  foreach ($vocabulary_fields as $t_field) {
    if (!empty($t_field)) {
      $taxonomy_fields_options = array_merge(
        $taxonomy_fields_options, array_combine(
          array_keys($t_field), array_keys($t_field)
      ));
    }
  }

  foreach ($field['settings']['allowed_values'] as $delta => $tree) {
    $delta_split = explode('_', $delta);
    $vocab_type = ucfirst($delta_split[0]);

    $form['allowed_values'][$delta] = array(
      '#type' => 'fieldset',
      '#title' => t('Settings for @vocab_type', array('@vocab_type' => $vocab_type)),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );

    $form['allowed_values'][$delta]['vocabulary'] = array(
      '#type' => 'select',
      '#title' => t('Vocabulary for @vocab_type', array('@vocab_type' => $vocab_type)),
      '#default_value' => $tree['vocabulary'],
      '#options' => $options,
      '#required' => TRUE,
      '#description' => t('The vocabulary which supplies the options for this field.'),
      '#disabled' => $has_data,
      '#prefix' => '<div class="ajax-vocabulary-conf-vocabulary">',
      '#suffix' => '</div>',
    );

    $form['allowed_values'][$delta]['parent'] = array(
      '#type' => 'value',
      '#value' => $tree['parent'],
    );

    // Skip adding ref_field_name for Make,
    // as it's the first link in relationships.
    if (strpos($delta, 'make_') !== FALSE) {
      continue;
    }

    $form['allowed_values'][$delta]['ref_field_name'] = array(
      '#type' => 'select',
      '#title' => t('Reference field name used for @vocab_type', array('@vocab_type' => $vocab_type)),
      '#default_value' => $tree['ref_field_name'],
      '#options' => $taxonomy_fields_options,
      '#required' => TRUE,
      '#description' => t('The reference field name used to connect link structure entities.'),
      '#disabled' => $has_data,
      '#prefix' => '<div class="ajax-vocabulary-conf-ref-field-name">',
      '#suffix' => '</div>',
    );
  }

  return $form;
}

/**
 * Implements hook_field_instance_settings_form().
 */
function car_reference_field_instance_settings_form($field, $instance) {
  // Option to restrict which vocabs can be selected.
  // This is used for the autocomplete widget to restrict results.
  if ($field['type'] == 'car_reference') {
    // Prepare default values.
    foreach ($instance['settings']['choose_from'] as $vocab) {
      if ($vocab) {
        $defaults[] = $vocab;
      }
    }
    $form['choose_from'] = array(
      '#type' => 'checkboxes',
      '#options' => array(
        'make' => t('Make'),
        'model' => t('Model'),
        'edition' => t('Edition'),
      ),
      '#title' => t('Choose which vocab users can choose from'),
      '#description' => t('Please select at least one vocab to choose results from. Currently only used for autocomplete widget.'),
      '#default_value' => $defaults,
      '#element_validate' => array('_choose_from_vocab_validate'),
    );
  }

  return $form;
}

/**
 * Validation function for 'choose_from' car reference instance setting.
 *
 * @see car_reference_field_instance_settings_form()
 */
function _choose_from_vocab_validate($element, &$form_state, $form) {
  // Ensure at least one vocab is chosen.
  if (empty($element['#value'])) {
    form_error($element, t('Please select at least one vocab.'));
  }

  // Unset empty values so that disallowing a vocab can be reverted.
  if (!empty($form_state['values']['instance']['settings']['choose_from'])) {
    foreach ($form_state['values']['instance']['settings']['choose_from'] as $option => $value) {
      if (empty($value)) {
        unset($form_state['values']['instance']['settings']['choose_from'][$option]);
      }
    }
  }
}

/**
 * Implements hook_field_formatter_info().
 */
function car_reference_field_formatter_info() {
  return array(
    'car_reference_link' => array(
      'label' => t('Link'),
      'field types' => array('car_reference'),
    ),
    'car_reference_plain' => array(
      'label' => t('Plain text'),
      'field types' => array('car_reference'),
    ),
    'car_reference_entity' => array(
      'label' => t('Rendered Entity'),
      'field types' => array('car_reference'),
      'settings' => array(
        'view_mode' => 'full',
        'vocabulary' => 'make',
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function car_reference_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $settings = $instance['display'][$view_mode]['settings'];
  $default_view_mode = $settings['view_mode'];
  $default_vocabulary = $settings['vocabulary'];
  $element['#tree'] = TRUE;

  $entity_info = entity_get_info('taxonomy_term');
  foreach ($entity_info['view modes'] as $term_view_mode => $data) {
    $options[$term_view_mode] = $data['label'];
  }
  $element['view_mode'] = array(
    '#title' => t('View mode'),
    '#description' => t('The view mode in which to render the taxonomy term'),
    '#type' => 'select',
    '#default_value' => isset($settings['view_mode']) ? $settings['view_mode'] : $default_view_mode,
    '#options' => $options,
  );

  $vocab_options = array(
    'make' => 'make',
    'model' => 'model',
    'edition' => 'edition',
  );
  $element['vocabulary'] = array(
    '#title' => t('Vocabulary'),
    '#description' => t('The vocabulary to use in the car reference field.'),
    '#type' => 'select',
    '#default_value' => isset($settings['vocabulary']) ? $settings['vocabulary'] : $default_vocabulary,
    '#options' => $vocab_options,
  );

  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function car_reference_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $instance['display'][$view_mode]['settings'];
  // $entity_info = entity_get_info('taxonomy_term');
  $summary = array();
  switch ($display['type']) {
    case 'car_reference_entity':
      $summary = array(
        '#type' => 'item',
        '#title' => t('Settings'),
        '#markup' => t('View mode: %mode Vocabulary: %vocab', array(
          '%mode' => $settings['view_mode'],
          '%vocab' => $settings['vocabulary'],
          )
        ),
      );

      break;
  }

  return drupal_render($summary);
}

/**
 * Implements hook_field_formatter_view().
 */
function car_reference_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'];

  switch ($display['type']) {
    case 'car_reference_link':
      foreach ($items as $delta => $item) {
        $term = $item['taxonomy_term'];
        $uri = entity_uri('taxonomy_term', $term);
        $element[$delta] = array(
          '#type' => 'link',
          '#title' => $term->name,
          '#href' => $uri['path'],
          '#options' => $uri['options'],
        );
      }
      break;

    case 'car_reference_plain':
      foreach ($items as $delta => $item) {
        $name = $item['taxonomy_term']->name;
        $element[$delta] = array(
          '#markup' => check_plain($name),
        );
      }
      break;

    case 'car_reference_entity':
      $vocab = $settings['vocabulary'];
      foreach ($items as $delta => $item) {
        $build = taxonomy_term_view($item['taxonomy_term'], $settings['view_mode']);
        $element[$delta] = array(
          '#markup' => drupal_render($build),
        );
      }
      break;
  }

  return $element;
}

/**
 * Implements hook_field_formatter_prepare_view().
 *
 * This preloads all taxonomy terms for multiple loaded objects at once and
 * unsets values for invalid terms that do not exist.
 */
function car_reference_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  $tids = array();

  // Collect every possible term attached to any of the fieldable entities.
  foreach ($entities as $id => $entity) {
    foreach ($items[$id] as $delta => $item) {
      // Force the array key to prevent duplicates.
      if (isset($item['edition_tid'])) {
        $tids[$item['edition_tid']] = $item['edition_tid'];
      }
      if (isset($item['model_tid'])) {
        $tids[$item['model_tid']] = $item['model_tid'];
      }
      if (isset($item['make_tid'])) {
        $tids[$item['make_tid']] = $item['make_tid'];
      }
    }
  }

  if ($tids) {
    $terms = taxonomy_term_load_multiple($tids);

    // Iterate through the fieldable entities to attach the loaded term data.
    foreach ($entities as $id => $entity) {
      $rekey = FALSE;

      foreach ($items[$id] as $delta => $item) {
        // If the vocabulary was set in the field formatter settings,
        // then load the term. Otherwise skip to the regular logic.
        $setting_vocabulary = empty($displays[$id]['settings']['vocabulary']) ? FALSE : $displays[$id]['settings']['vocabulary'];
        if (!empty($setting_vocabulary) && isset($terms[$item[$setting_vocabulary . '_tid']])) {
          $items[$id][$delta]['taxonomy_term'] = $terms[$item[$setting_vocabulary . '_tid']];
          continue;
        }

        // Check whether the taxonomy term field instance value could be loaded.
        if (isset($terms[$item['edition_tid']])) {
          $items[$id][$delta]['taxonomy_term'] = $terms[$item['edition_tid']];
        }
        elseif (isset($terms[$item['model_tid']])) {
          $items[$id][$delta]['taxonomy_term'] = $terms[$item['model_tid']];
        }
        elseif (isset($terms[$item['make_tid']])) {
          $items[$id][$delta]['taxonomy_term'] = $terms[$item['make_tid']];
        }
        // Otherwise, unset the instance value, since the term does not exist.
        else {
          unset($items[$id][$delta]);
          $rekey = TRUE;
        }
      }

      if ($rekey) {
        // Rekey the items array.
        $items[$id] = array_values($items[$id]);
      }
    }
  }
}

/**
 * Implements hook_field_widget_info().
 */
function car_reference_field_widget_info() {
  return array(
    'car_reference_tids' => array(
      'label' => t('Text field'),
      'field types' => array('car_reference'),
      'settings' => array('size' => 10),
    ),
    'car_reference_autocomplete' => array(
      'label' => t('Autocomplete term widget'),
      'field types' => array('car_reference'),
      'settings' => array(
        'size' => 60,
        'autocomplete_path' => 'car_reference/autocomplete',
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function car_reference_field_widget_settings_form($field, $instance) {
  $form = array();
  $widget = $instance['widget'];
  $settings = $widget['settings'];

  if ($widget['type'] == 'car_reference_tids') {
    $form['size'] = array(
      '#type' => 'textfield',
      '#title' => t('Size of textfield'),
      '#default_value' => $settings['size'],
      '#required' => TRUE,
      '#element_validate' => array('element_validate_integer_positive'),
    );
  }

  return $form;
}

/**
 * Implements hook_field_widget_form().
 */
function car_reference_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {

  $base = $element;

  switch ($instance['widget']['type']) {
    case 'car_reference_tids':

      $element['make_tid'] = array(
        '#type' => 'textfield',
        '#title' => t('Make'),
        '#default_value' => isset($items[$delta]['make_tid']) ? $items[$delta]['make_tid'] : NULL,
        '#size' => $instance['widget']['settings']['size'],
        '#maxlength' => $field['settings']['max_length'],
        '#attributes' => array('class' => array('text-full')),
        ) + $base;

      $element['model_tid'] = array(
        '#type' => 'textfield',
        '#title' => t('Model'),
        '#default_value' => isset($items[$delta]['model_tid']) ? $items[$delta]['model_tid'] : NULL,
        '#size' => $instance['widget']['settings']['size'],
        '#maxlength' => $field['settings']['max_length'],
        '#attributes' => array('class' => array('text-full')),
        ) + $base;

      $element['edition_tid'] = array(
        '#type' => 'textfield',
        '#title' => t('Edition'),
        '#default_value' => isset($items[$delta]['edition_tid']) ? $items[$delta]['edition_tid'] : NULL,
        '#size' => $instance['widget']['settings']['size'],
        '#maxlength' => $field['settings']['max_length'],
        '#attributes' => array('class' => array('text-full')),
        ) + $base;

      break;

    case 'car_reference_autocomplete':

      if (isset($items[$delta]['edition_tid'])) {
        $term = isset($items[$delta]['taxonomy_term']) ? $items[$delta]['taxonomy_term'] : taxonomy_term_load($items[$delta]['edition_tid']);
      }
      elseif (isset($items[$delta]['model_tid'])) {
        $term = isset($items[$delta]['taxonomy_term']) ? $items[$delta]['taxonomy_term'] : taxonomy_term_load($items[$delta]['model_tid']);
      }
      elseif (isset($items[$delta]['make_tid'])) {
        $term = isset($items[$delta]['taxonomy_term']) ? $items[$delta]['taxonomy_term'] : taxonomy_term_load($items[$delta]['make_tid']);
      }

      // Use a fake element to store the term name value.
      $element['taxonomy_term'] = array(
        '#type' => 'textfield',
        '#default_value' => (isset($term->name)) ? $term->name : '',
        '#autocomplete_path' => $instance['widget']['settings']['autocomplete_path'] . '/' . $instance['entity_type'] . '/' . $instance['bundle'] . '/' . $field['field_name'],
        '#size' => $instance['widget']['settings']['size'],
        '#maxlength' => 1024,
        '#element_validate' => array('car_reference_autocomplete_validate'),
        ) + $base;
      break;
  }

  return $element;
}

/**
 * Impliments hook_field_is_empty().
 */
function car_reference_field_is_empty($item, $field) {
  if (!is_array($item) || empty($item['make_tid']) || (string) $item['make_tid'] == '0') {
    return TRUE;
  }
  return FALSE;
}

/**
 * Form element validate handler for car reference autocomplete element.
 */
function car_reference_autocomplete_validate($element, &$form_state) {
  // Autocomplete widgets do not send their tids in the form, so we must detect
  // them here and process them independently.
  $value = array();

  $field_value = trim($element['#value']);
  if (!empty($field_value)) {
    // Use choose_from settings for field instance.
    $field_instance = field_info_instance($element['#entity_type'], $element['#field_name'], $element['#bundle']);
    // Reverse array to get edition first.
    $choose_from = array_reverse($field_instance['settings']['choose_from'], TRUE);
    foreach ($choose_from as $machine_name => $allowed) {
      if ($allowed) {
        if ($vocabulary = taxonomy_vocabulary_machine_name_load($machine_name)) {
          if ($possibilities = taxonomy_term_load_multiple(array(), array('name' => $field_value, 'vid' => $vocabulary->vid))) {
            $term = array_pop($possibilities);
            break;
          }
        }
      }
    }

    if (isset($term->vocabulary_machine_name)) {
      // Get the field settings.
      $field = field_widget_field($element, $form_state);

      // It is supposed that referenced fields are required on field setting.
      $make_ref_field = $field['settings']['allowed_values']['model_vocabulary']['ref_field_name'];
      $model_ref_field = $field['settings']['allowed_values']['edition_vocabulary']['ref_field_name'];

      if ($term->vocabulary_machine_name == $field['settings']['allowed_values']['edition_vocabulary']['vocabulary']) {
        $value['edition_tid'] = $term->tid;
        if ($model = taxonomy_term_load($term->{$model_ref_field}[LANGUAGE_NONE][0]['tid'])) {
          $value['model_tid'] = $model->tid;
          $value['make_tid'] = $model->{$make_ref_field}[LANGUAGE_NONE][0]['tid'];
        }
      }
      elseif ($term->vocabulary_machine_name == $field['settings']['allowed_values']['model_vocabulary']['vocabulary']) {
        $value['model_tid'] = $term->tid;
        $value['make_tid'] = $term->{$make_ref_field}[LANGUAGE_NONE][0]['tid'];
      }
      elseif ($term->vocabulary_machine_name == $field['settings']['allowed_values']['make_vocabulary']['vocabulary']) {
        $value['make_tid'] = $term->tid;
      }
    }
    elseif (empty($element['#required'])) {
      drupal_set_message(t('Invalid Car: :car', array(':car' => $element['#title'])), 'error');
    }
  }

  // Autocomplete uses a fake element so the values needs to be added
  // to the delta and not the element.
  array_pop($element['#parents']);

  form_set_value($element, $value, $form_state);
}

/**
 * Implements hook_field_validate().
 *
 * Taxonomy field settings allow for either a single vocabulary ID, multiple
 * vocabulary IDs, or sub-trees of a vocabulary to be specified as allowed
 * values, although only the first of these is supported via the field UI.
 * Confirm that terms entered as values meet at least one of these conditions.
 *
 * Possible error codes:
 * - 'taxonomy_term_illegal_value':
 *   The value is not part of the list of allowed values.
 */
function car_reference_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  // Don't validate form when configuring field on the field UI.
  // When editing a node, $entity will be a class.
  if (is_null($entity)) {
    return;
  }

  foreach ($items as $delta => $item) {
    $validate = TRUE;

    // Get the vocabularies from the field configuration.
    $vocabularies = array();
    foreach ($field['settings']['allowed_values'] as $value) {
      $vocabularies[] = $value['vocabulary'];
    }

    // Reverse and loop the vocabularies so that the most specific part
    // of the field is checked first. If the condition is satisfied,
    // we don't need to check the other items.
    foreach (array_reverse($vocabularies) as $vocabulary_name) {
      if (in_array($vocabulary_name, $instance['settings']['choose_from'], TRUE)) {
        $key = $vocabulary_name . '_tid';
        if (isset($item[$key]) && $term = taxonomy_term_load($item[$key])) {
          $validate = TRUE;
          break;
        }
        else {
          if ($instance['required']) {
            $validate = FALSE;
          }
        }
      }
    }

    if (!$validate) {
      $errors[$field['field_name']][$langcode][$delta][] = array(
        'error' => 'taxonomy_term_reference_illegal_value',
        'message' => t('%name: illegal value.', array('%name' => $instance['label'])),
      );
    }
  }
}

/**
 * Implements hook_entity_insert().
 */
function car_reference_entity_insert($entity, $type) {
  if ($type == 'node') {
    car_reference_build_node_index($entity);
  }
}

/**
 * Implements hook_entity_update().
 */
function car_reference_entity_update($entity, $type) {
  if ($type == 'node') {
    car_reference_build_node_index($entity);
  }
}

/**
 * Builds and inserts car reference taxonomy index entries for a given node.
 *
 * The index lists all terms that are related to a given node entity, and is
 * therefore maintained at the entity level.
 *
 * @param object $node
 *   The node object.
 */
function car_reference_build_node_index($node) {
  // We maintain a denormalized table of term/node relationships, containing
  // only data for current, published nodes.
  $status = NULL;
  if (variable_get('taxonomy_maintain_index_table', TRUE)) {
    // If a node property is not set in the node object when node_save() is
    // called, the old value from $node->original is used.
    if (!empty($node->original)) {
      $status = (int) (!empty($node->status) || (!isset($node->status) && !empty($node->original->status)));
      $sticky = (int) (!empty($node->sticky) || (!isset($node->sticky) && !empty($node->original->sticky)));
    }
    else {
      $status = (int) (!empty($node->status));
      $sticky = (int) (!empty($node->sticky));
    }
  }
  // We only maintain the taxonomy index for published nodes.
  if ($status) {
    // Collect a unique list of all the term IDs from all node fields.
    $tid_all = array();
    foreach (field_info_instances('node', $node->type) as $instance) {
      $field_name = $instance['field_name'];
      $field = field_info_field($field_name);
      if ($field['module'] == 'car_reference' && $field['storage']['type'] == 'field_sql_storage') {
        // If a field value is not set in the node object when node_save() is
        // called, the old value from $node->original is used.
        if (isset($node->{$field_name})) {
          $items = $node->{$field_name};
        }
        elseif (isset($node->original->{$field_name})) {
          $items = $node->original->{$field_name};
        }
        else {
          continue;
        }
        foreach (field_available_languages('node', $field) as $langcode) {
          if (!empty($items[$langcode])) {
            foreach ($items[$langcode] as $item) {
              $tid_all[$item['make_tid']] = $item['make_tid'];
              if (isset($item['model_tid'])) {
                $tid_all[$item['model_tid']] = $item['model_tid'];
              }
              if (isset($item['edition_tid'])) {
                $tid_all[$item['edition_tid']] = $item['edition_tid'];
              }
            }
          }
        }
      }
    }
    // Insert index entries for all the node's terms.
    if (!empty($tid_all)) {
      $query = db_insert('taxonomy_index')
        ->fields(array('nid', 'tid', 'sticky', 'created'));
      foreach ($tid_all as $tid) {
        $query->values(array(
          'nid' => $node->nid,
          'tid' => $tid,
          'sticky' => $sticky,
          'created' => $node->created,
        ));
      }
      $query->execute();
    }
  }
}

/**
 * Implements hook_token_info().
 */
function car_reference_token_info() {
  $info['tokens']['node']['car_reference_make_name'] = array(
    'name' => t('Car reference make name'),
    'description' => t('Car reference make name.'),
  );
  $info['tokens']['node']['car_reference_make_name_url'] = array(
    'name' => t('Car reference make name for URLs'),
    'description' => t('Car reference make name value for use in URLs.'),
  );
  $info['tokens']['node']['car_reference_make_term_alias'] = array(
    'name' => t('Car reference make taxonomy term URL alias'),
    'description' => t('The make terms URL alias. eg ford'),
  );

  $info['tokens']['node']['car_reference_model_name'] = array(
    'name' => t('Car reference model name'),
    'description' => t('Car reference model name.'),
  );
  $info['tokens']['node']['car_reference_model_name_url'] = array(
    'name' => t('Car reference model name for URLs'),
    'description' => t('Car reference model name value for use in URLs.'),
  );
  $info['tokens']['node']['car_reference_model_term_alias'] = array(
    'name' => t('Car reference model taxonomy term URL alias'),
    'description' => t('The model terms URL alias. eg ford/focus'),
  );

  $info['tokens']['node']['car_reference_edition_name'] = array(
    'name' => t('Car reference edition name'),
    'description' => t('Car reference edition name.'),
  );
  $info['tokens']['node']['car_reference_edition_name_url'] = array(
    'name' => t('Car reference edition name for URLs'),
    'description' => t('Car reference edition name value for use in URLs.'),
  );
  return $info;
}

/**
 * Implements hook_tokens().
 */
function car_reference_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];

    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'car_reference_make_name':
        case 'car_reference_make_name_url':
          if (!empty($node->field_primary_car_reference[LANGUAGE_NONE][0]['make_tid'])) {
            $replacements[$original] = car_reference_get_make_name($node->field_primary_car_reference[LANGUAGE_NONE][0]['make_tid']);
          }
          break;

        case 'car_reference_make_term_alias':
          if (!empty($node->field_primary_car_reference[LANGUAGE_NONE][0]['make_tid'])) {
            $replacements[$original] = drupal_lookup_path('alias', 'taxonomy/term/' . $node->field_primary_car_reference[LANGUAGE_NONE][0]['make_tid']);
          }
          break;

        case 'car_reference_model_name':
        case 'car_reference_model_name_url':
          if (!empty($node->field_primary_car_reference[LANGUAGE_NONE][0]['model_tid'])) {
            $replacements[$original] = car_reference_get_model_name($node->field_primary_car_reference[LANGUAGE_NONE][0]['model_tid']);
          }
          break;

        case 'car_reference_model_term_alias':
          if (!empty($node->field_primary_car_reference[LANGUAGE_NONE][0]['model_tid'])) {
            $replacements[$original] = drupal_lookup_path('alias', 'taxonomy/term/' . $node->field_primary_car_reference[LANGUAGE_NONE][0]['model_tid']);
          }
          break;

        case 'car_reference_edition_name':
        case 'car_reference_edition_name_url':
          if (!empty($node->field_primary_car_reference[LANGUAGE_NONE][0]['edition_tid'])) {
            $replacements[$original] = car_reference_get_edition_name($node->field_primary_car_reference[LANGUAGE_NONE][0]['edition_tid']);
          }
          break;
      }

      if (!empty($replacements[$original]) && ($name == 'car_reference_edition_name_url' || $name == 'car_reference_model_name_url' || $name == 'car_reference_make_name_url')) {
        if (!function_exists('pathauto_cleanstring')) {
          module_load_include('inc', 'pathauto');
        }
        $replacements[$original] = pathauto_cleanstring($replacements[$original]);
      }
    }
  }
  return $replacements;
}

/**
 * Returns a model name given a model tid.
 *
 * @param string $tid
 *   Taxonomy term ID.
 */
function car_reference_get_model_name($tid) {
  $query = db_select('field_data_field_short_name', 'mn')->fields('mn', array('field_short_name_value'));
  $query->condition('mn.entity_id', $tid)->condition('mn.entity_type', 'taxonomy_term')->condition('deleted', 0);
  return $query->execute()->fetchField();
}

/**
 * Returns an edition name given an edition tid.
 *
 * @param string $tid
 *   Taxonomy term ID.
 */
function car_reference_get_edition_name($tid) {
  $query = db_select('field_data_field_short_name', 'en')->fields('en', array('field_short_name_value'));
  $query->condition('en.entity_id', $tid)->condition('en.entity_type', 'taxonomy_term')->condition('deleted', 0);
  return $query->execute()->fetchField();
}

/**
 * Returns a make name given a make tid.
 *
 * @param string $tid
 *   Taxonomy term ID.
 */
function car_reference_get_make_name($tid) {
  if ($term = taxonomy_term_load($tid)) {
    return $term->name;
  }
}

/**
 * Returns the key value pairs of the given tids for use in adtags etc.
 *
 * @param array $tids
 *   Taxonomy term IDs.
 */
function car_reference_get_key_value_pairs($tids) {
  $kvp = array();
  $terms = taxonomy_term_load_multiple($tids);
  foreach ($terms as $term) {
    switch ($term->vocabulary_machine_name) {
      case 'make':
      case 'model':
        $kvp[$term->vocabulary_machine_name][] = $term->name;
        break;

      case 'edition':
        $kvp[$term->vocabulary_machine_name][] = $term->name;
        // Get the body style from the edition name.
        $field = field_get_items('taxonomy_term', $term, 'field_short_name');
        $kvp['bodystyle'][] = $field[0]['value'];
        break;
    }
  }

  return $kvp;
}

/**
 * Implements hook_taxonomy_term_update().
 *
 * Update all the record related to car_reference field.
 */
function car_reference_taxonomy_term_update($term) {

  $car_reference_fields = _get_car_reference_fields();
  $act_on_vocs = array();
  $changed = FALSE;

  foreach ($car_reference_fields as $field_name) {
    // Get the field settings data about car reference.
    $field_conf = field_info_field('field_primary_car_reference');
    $confs = $field_conf['settings']['allowed_values'];
    // We don't need to act on make represented vocabulary.
    $act_on_vocs[] = $confs['model_vocabulary']['vocabulary'];
    $act_on_vocs[] = $confs['edition_vocabulary']['vocabulary'];
  }

  // The parent can be changed just for model and edition.
  // This would mean that we should act only on this terms update
  // in order to update node related data to that.
  if (!in_array($term->vocabulary_machine_name, $act_on_vocs)) {
    return;
  }
  $term_original = $term->original;

  // Detect any changes on ref_field level.
  foreach ($act_on_vocs as $voc_name) {
    // Get the current value.
    $current_field = field_get_items('taxonomy_term', $term, $confs[$voc_name . '_vocabulary']['ref_field_name']);
    $current_field_val = !empty($current_field) ? $current_field[0]['tid'] : FALSE;
    // Get the original value.
    $original_current_field = field_get_items('taxonomy_term', $term_original, $confs[$voc_name . '_vocabulary']['ref_field_name']);
    $original_current_field_val = !empty($original_current_field) ? $original_current_field[0]['tid'] : FALSE;

    if ($current_field_val != $original_current_field_val) {
      $changed = TRUE;
      break;
    }
  }

  if (!$changed) {
    return;
  }

  // Act in case the tid was changed to another tid.
  // Fields should not be empty as they are required.
  if ($original_current_field_val && $current_field_val) {
    $rows_to_update = _car_reference_get_fields_rows_to_update($car_reference_fields, $original_current_field_val, $current_field_val);
    $rows_to_update += _car_reference_get_taxonomy_rows_to_update($original_current_field_val, $current_field_val);
  }

  if (!empty($rows_to_update)) {
    _car_reference_push_update($rows_to_update);
  }
}

/**
 * Get the rows from car_reference field type which are going to be updated,
 * after changing the relationship between make/model/edition.
 */
function _car_reference_get_fields_rows_to_update($car_reference_fields, $original_current_field_val, $current_field_val) {
  $rows_to_update = array();

  foreach ($car_reference_fields as $field_name) {
    $query = db_select('field_data_' . $field_name, 'fcr');
    $query->fields('fcr');
    // Match records related to the current modified one.
    $db_or = db_or()
      ->condition('fcr.' . $field_name . '_make_tid', $original_current_field_val)
      ->condition('fcr.' . $field_name . '_model_tid', $original_current_field_val)
      ->condition('fcr.' . $field_name . '_edition_tid', $original_current_field_val);
    $query->condition($db_or);

    foreach ($query->execute() as $record) {
      // Skip scheduled records for deletion.
      if ($record->deleted) {
        continue;
      }

      // Shut down the warning here, because the not all car references
      // entities are required(edition->make->model), but we can be sure we are
      // processing correct data as conditions was applied into mysql query.
      $related_record = @array_flip((array) $record);

      $rows_to_update['field_data_' . $field_name] = array(
        'table' => 'field_data_' . $field_name,
        'update_column_name' => $related_record[$original_current_field_val],
        'update_column_value' => $current_field_val,
        'update_original_column_value' => $original_current_field_val,
      );

      // One result is enough in order to update all the records.
      break 1;
    }
  }

  return $rows_to_update;
}

/**
 * Get the rows from taxonomy_index table which are going to be updated,
 * after changing the relationship between make/model/edition.
 */
function _car_reference_get_taxonomy_rows_to_update($original_current_field_val, $current_field_val) {
  $rows_to_update = $rows_id = array();

  $query = db_select('taxonomy_index', 'ti');
  $query->fields('ti');
  // Match records related to the current modified one.
  $query->condition('ti.tid', $original_current_field_val);

  foreach ($query->execute() as $record) {
    $rows_id[] = $record->nid;
    $rows_to_update['taxonomy_index'] = array(
      'table' => 'taxonomy_index',
      'update_column_name' => 'tid',
      'update_column_value' => $current_field_val,
      'update_original_column_value' => $original_current_field_val,
    );
  }

  // Store all the ids in order to clear the entity cache.
  $rows_to_update['taxonomy_index']['entity_ids_updated'] = $rows_id;

  return $rows_to_update;
}

/**
 * Detect the fields using car_reference field type.
 */
function _get_car_reference_fields() {
  $query = db_select('field_config', 'fc');
  $query->fields('fc', array('field_name', 'data'));
  $query->condition('fc.type', 'car_reference');
  $query->condition('fc.storage_type', 'field_sql_storage');
  return $query->execute()->fetchCol();
}

/**
 * Update all detected rows.
 */
function _car_reference_push_update($rows_to_update) {
  // Loop through the tables.
  foreach ($rows_to_update as $row) {
    db_update($row['table'])
      ->fields(array($row['update_column_name'] => $row['update_column_value']))
      ->condition($row['update_column_name'], $row['update_original_column_value'])
      ->expression($row['update_column_name'], 'replace(' . $row['update_column_name'] . ', :old_val, :new_val)', array(
        ':old_val' => $row['update_original_column_value'],
        ':new_val' => $row['update_column_value'],
      ))
      ->execute();

    // Clear the nodes cache.
    if (!empty($row['entity_ids_updated'])) {
      entity_get_controller('node')->resetCache($row['entity_ids_updated']);
    }
  }
}
