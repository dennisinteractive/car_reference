<?php

/**
 * Implements hook_menu().
 */
function car_reference_menu() {
  $items = array();

  $items['car_reference/autocomplete'] = array(
    'title' => 'Autocomplete Car Reference',
    'page callback' => 'car_reference_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'car_reference.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_views_api().
 */
function car_reference_views_api() {
  return array("version" => "3.0");
}

/**
 * Implements hook_field_info().
 *
 * Field settings:
 *
 */
function car_reference_field_info() {
  return array(

    'car_reference' => array(
      'label' => t('Car reference'),
      'description' => t('This field stores a reference to a make, model and edition taxonomy term.'),
      'default_widget' => 'car_reference_tids',
      'default_formatter' => 'car_reference_link',
      'settings' => array(
        'allowed_values' => array(
          'make_vocabulary' => array(
            'vocabulary' => 'make',
            'parent' => '0',
          ),
          'model_vocabulary' => array(
            'vocabulary' => 'model',
            'parent' => '0',
          ),
          'edition_vocabulary' => array(
            'vocabulary' => 'edition',
            'parent' => '0',
          ),
        ),
      ),
      'instance_settings' => array(
        //which vocabs to return result from, for autocomplete widget
        'choose_from' => array('make' => 'make', 'model' => 'model', 'edition' => 'edition'),
      ),
      // Support hook_entity_property_info() from contrib "Entity API".
      'property_type' => 'taxonomy_term',
    ),

  );
}

/**
 * Implements hook_field_settings_form().
 */
function car_reference_field_settings_form($field, $instance, $has_data) {
  // Get proper values for 'allowed_values_function', which is a core setting.
  $vocabularies = taxonomy_get_vocabularies();
  $options = array();
  foreach ($vocabularies as $vocabulary) {
    $options[$vocabulary->machine_name] = $vocabulary->name;
  }
  $form['allowed_values'] = array(
    '#tree' => TRUE,
  );

  foreach ($field['settings']['allowed_values'] as $delta => $tree) {
    $vocab_type = explode('_', $delta);
    $form['allowed_values'][$delta]['vocabulary'] = array(
      '#type' => 'select',
      '#title' => t('Vocabulary for @vocab_type', array('@vocab_type' => $vocab_type[0])),
      '#default_value' => $tree['vocabulary'],
      '#options' => $options,
      '#required' => TRUE,
      '#description' => t('The vocabulary which supplies the options for this field.'),
      '#disabled' => $has_data,
    );
    $form['allowed_values'][$delta]['parent'] = array(
      '#type' => 'value',
      '#value' => $tree['parent'],
    );
  }

  return $form;
}

/**
 * Implements hook_field_instance_settings_form().
 */
function car_reference_field_instance_settings_form($field, $instance) {
  //Option to restrict which vocabs can be selected. This is used for the autocomplete widget to restrict results.
  if ($field['type'] == 'car_reference') {
    //prepare default values
    foreach($instance['settings']['choose_from'] as $vocab) {
      if ($vocab) {
        $defaults[] = $vocab;
      }
    }
    $form['choose_from'] = array(
      '#type' => 'checkboxes',
      '#options' => array('make' => t('Make'), 'model' => t('Model'), 'edition' => t('Edition')),
      '#title' => t('Choose which vocab users can choose from'),
      '#description' => t('Please select at least one vocab to choose results from. Currently only used for autocomplete widget.'),
      '#default_value' => $defaults,
      '#element_validate' => array('_choose_from_vocab_validate'),
    );
  }
  return $form;
}

/**
 * Validation function for 'choose_from' car reference instance setting.
 * @see car_reference_field_instance_settings_form().
 */
function _choose_from_vocab_validate($element, &$form_state, $form) {
  //Ensure at least one vocab is chosen.
  if (empty($element['#value'])) {
    form_error($element, t('Please select at least one vocab.'));
  }

  // Unset empty values so that disallowing a vocab can be reverted.
  if (!empty($form_state['values']['instance']['settings']['choose_from'])) {
    foreach ($form_state['values']['instance']['settings']['choose_from'] as $option => $value) {
      if (empty($value)) {
        unset($form_state['values']['instance']['settings']['choose_from'][$option]);
      }
    }
  }
}

/**
 * Implements hook_field_formatter_info().
 */
function car_reference_field_formatter_info() {
  return array(
    'car_reference_link' => array(
      'label' => t('Link'),
      'field types' => array('car_reference'),
    ),
    'car_reference_plain' => array(
      'label' => t('Plain text'),
      'field types' => array('car_reference'),
    ),
    'car_reference_entity' => array(
      'label' => t('Rendered Entity'),
      'field types' => array('car_reference'),
      'settings' => array(
        'view_mode' => 'full',
        'vocabulary' => 'make',
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function car_reference_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $settings = $instance['display'][$view_mode]['settings'];
  $default_view_mode = $settings['view_mode'];
  $default_vocabulary = $settings['vocabulary'];
  $element['#tree'] = TRUE;

  $entity_info = entity_get_info('taxonomy_term');
  foreach ($entity_info['view modes'] as $term_view_mode => $data) {
    $options[$term_view_mode] = $data['label'];
  }
  $element['view_mode'] = array(
    '#title' => t('View mode'),
    '#description' => t('The view mode in which to render the taxonomy term'),
    '#type' => 'select',
    '#default_value' => isset($settings['view_mode']) ? $settings['view_mode'] : $default_view_mode,
    '#options' => $options,
  );

  $vocab_options = array(
    'make' => 'make',
    'model' => 'model',
    'edition' => 'edition',
  );
  $element['vocabulary'] = array(
    '#title' => t('Vocabulary'),
    '#description' => t('The vocabulary to use in the car reference field.'),
    '#type' => 'select',
    '#default_value' => isset($settings['vocabulary']) ? $settings['vocabulary'] : $default_vocabulary,
    '#options' => $vocab_options,
  );

  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function car_reference_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $instance['display'][$view_mode]['settings'];
  $entity_info = entity_get_info('taxonomy_term');

  switch ($display['type']) {
    case 'car_reference_entity':
        $summary = array(
          '#type' => 'item',
          '#title' => t('Settings'),
          '#markup' => t('View mode: %mode Vocabulary: %vocab',
                          array(
                            '%mode' => $settings['view_mode'],
                            '%vocab' => $settings['vocabulary']
                          )
                        ),
        );

        return drupal_render($summary);
      break;
  }
}

/**
 * Implements hook_field_formatter_view().
 */
function car_reference_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'];

  switch ($display['type']) {
    case 'car_reference_link':
      foreach ($items as $delta => $item) {
        $term = $item['taxonomy_term'];
        $uri = entity_uri('taxonomy_term', $term);
        $element[$delta] = array(
          '#type' => 'link',
          '#title' => $term->name,
          '#href' => $uri['path'],
          '#options' => $uri['options'],
        );
      }
      break;

    case 'car_reference_plain':
      foreach ($items as $delta => $item) {
        $name = $item['taxonomy_term']->name;
        $element[$delta] = array(
          '#markup' => check_plain($name),
        );
      }
      break;

    case 'car_reference_entity':
      $vocab = $settings['vocabulary'];
      foreach ($items as $delta => $item) {
        $build = taxonomy_term_view($item['taxonomy_term'], $settings['view_mode']);
        $element[$delta] = array(
          '#markup' => drupal_render($build),
        );
      }
      break;
  }

  return $element;
}

/**
 * Implements hook_field_formatter_prepare_view().
 *
 * This preloads all taxonomy terms for multiple loaded objects at once and
 * unsets values for invalid terms that do not exist.
 */
function car_reference_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  $tids = array();

  // Collect every possible term attached to any of the fieldable entities.
  foreach ($entities as $id => $entity) {
    foreach ($items[$id] as $delta => $item) {
      // Force the array key to prevent duplicates.
      if (isset($item['edition_tid'])) {
        $tids[$item['edition_tid']] = $item['edition_tid'];
      }
      if (isset($item['model_tid'])) {
        $tids[$item['model_tid']] = $item['model_tid'];
      }
      if (isset($item['make_tid'])) {
        $tids[$item['make_tid']] = $item['make_tid'];
      }
    }
  }

  if ($tids) {
    $terms = taxonomy_term_load_multiple($tids);

    // Iterate through the fieldable entities again to attach the loaded term data.
    foreach ($entities as $id => $entity) {
      $rekey = FALSE;

      foreach ($items[$id] as $delta => $item) {
        // If the vocabulary was set in the field formatter settings, then load the term. Otherwise skip to the regular logic.
        $setting_vocabulary = empty($displays[$id]['settings']['vocabulary']) ? false : $displays[$id]['settings']['vocabulary'];
        if (!empty($setting_vocabulary) && isset($terms[$item[$setting_vocabulary . '_tid']])) {
          $items[$id][$delta]['taxonomy_term'] = $terms[$item[$setting_vocabulary . '_tid']];
          continue;
        }

        // Check whether the taxonomy term field instance value could be loaded.
        if (isset($terms[$item['edition_tid']])) {
          $items[$id][$delta]['taxonomy_term'] = $terms[$item['edition_tid']];
        }
        elseif (isset($terms[$item['model_tid']])) {
          $items[$id][$delta]['taxonomy_term'] = $terms[$item['model_tid']];
        }
        elseif (isset($terms[$item['make_tid']])) {
          $items[$id][$delta]['taxonomy_term'] = $terms[$item['make_tid']];
        }
        // Otherwise, unset the instance value, since the term does not exist.
        else {
          unset($items[$id][$delta]);
          $rekey = TRUE;
        }
      }

      if ($rekey) {
        // Rekey the items array.
        $items[$id] = array_values($items[$id]);
      }
    }
  }
}


/**
 * Implements hook_field_widget_info().
 */
function car_reference_field_widget_info() {
  return array(
    'car_reference_tids' => array(
      'label' => t('Text field'),
      'field types' => array('car_reference'),
      'settings' => array('size' => 10),
    ),
    'car_reference_autocomplete' => array(
      'label' => t('Autocomplete term widget'),
      'field types' => array('car_reference'),
      'settings' => array(
        'size' => 60,
        'autocomplete_path' => 'car_reference/autocomplete',
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function car_reference_field_widget_settings_form($field, $instance) {
  $form = array();
  $widget = $instance['widget'];
  $settings = $widget['settings'];

  if ($widget['type'] == 'car_reference_tids') {
    $form['size'] = array(
      '#type' => 'textfield',
      '#title' => t('Size of textfield'),
      '#default_value' => $settings['size'],
      '#required' => TRUE,
      '#element_validate' => array('element_validate_integer_positive'),
    );
  }

  return $form;
}

/**
 * Implements hook_field_widget_form().
 */
function car_reference_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {

  $base = $element;

  switch ($instance['widget']['type']) {
    case 'car_reference_tids':

      $element['make_tid'] = array(
      '#type' => 'textfield',
      '#title' => t('Make'),
      '#default_value' => isset($items[$delta]['make_tid']) ? $items[$delta]['make_tid'] : NULL,
      '#size' => $instance['widget']['settings']['size'],
      '#maxlength' => $field['settings']['max_length'],
      '#attributes' => array('class' => array('text-full')),
      ) + $base;

      $element['model_tid'] = array(
        '#type' => 'textfield',
        '#title' => t('Model'),
        '#default_value' => isset($items[$delta]['model_tid']) ? $items[$delta]['model_tid'] : NULL,
        '#size' => $instance['widget']['settings']['size'],
        '#maxlength' => $field['settings']['max_length'],
        '#attributes' => array('class' => array('text-full')),
      ) + $base;

      $element['edition_tid'] = array(
        '#type' => 'textfield',
        '#title' => t('Edition'),
        '#default_value' => isset($items[$delta]['edition_tid']) ? $items[$delta]['edition_tid'] : NULL,
        '#size' => $instance['widget']['settings']['size'],
        '#maxlength' => $field['settings']['max_length'],
        '#attributes' => array('class' => array('text-full')),
      ) + $base;

      break;

    case 'car_reference_autocomplete':

      if (isset($items[$delta]['edition_tid'])) {
        $term = isset($items[$delta]['taxonomy_term']) ? $items[$delta]['taxonomy_term'] : taxonomy_term_load($items[$delta]['edition_tid']);
      }
      elseif (isset($items[$delta]['model_tid'])) {
        $term = isset($items[$delta]['taxonomy_term']) ? $items[$delta]['taxonomy_term'] : taxonomy_term_load($items[$delta]['model_tid']);
      }
      elseif (isset($items[$delta]['make_tid'])) {
        $term = isset($items[$delta]['taxonomy_term']) ? $items[$delta]['taxonomy_term'] : taxonomy_term_load($items[$delta]['make_tid']);
      }

      // Use a fake element to store the term name value
      $element['taxonomy_term'] = array(
        '#type' => 'textfield',
        '#default_value' => (isset($term->name))?$term->name:'',
        '#autocomplete_path' => $instance['widget']['settings']['autocomplete_path'] . '/' . $instance['entity_type'] . '/' . $instance['bundle'] . '/' . $field['field_name'],
        '#size' => $instance['widget']['settings']['size'],
        '#maxlength' => 1024,
        '#element_validate' => array('car_reference_autocomplete_validate'),
      ) + $base;
      break;
  }

  return $element;
}

/**
 * Impliments hook_field_is_empty()
 */
function car_reference_field_is_empty($item, $field) {
  if (!is_array($item) || empty($item['make_tid']) || (string) $item['make_tid'] == '0') {
    return TRUE;
  }
  return FALSE;
}

/**
 * Form element validate handler for car reference autocomplete element.
 */
function car_reference_autocomplete_validate($element, &$form_state) {

  // Autocomplete widgets do not send their tids in the form, so we must detect
  // them here and process them independently.
  $value = array();

  if ($term = $element['#value']) {
    // Store the raw value to use for validation.
    $value['raw_input'] = $term;

    // Collect candidate vocabularies.
    $field = field_widget_field($element, $form_state);
    $vocabularies = array();

    // Use choose_from settings for field instance.
    $field_instance = field_info_instance($element['#entity_type'], $element['#field_name'], $element['#bundle']);
    // Reverse array to get edition first.
    $choose_from = array_reverse($field_instance['settings']['choose_from'], TRUE);
    foreach ($choose_from as $machine_name => $allowed) {
      if ($allowed) {
        if ($vocabulary = taxonomy_vocabulary_machine_name_load($machine_name)) {
          if ($possibilities = taxonomy_term_load_multiple(array(), array('name' => trim($term), 'vid' => $vocabulary->vid))) {
            $term = array_pop($possibilities);
            break;
          }
        }
      }
    }

    if (isset($term->vocabulary_machine_name)) {
      if ($term->vocabulary_machine_name == $field['settings']['allowed_values']['edition_vocabulary']['vocabulary']) {
        $value['edition_tid'] = $term->tid;
        if($model = taxonomy_term_load($term->field_model[LANGUAGE_NONE][0]['tid'])) {
          $value['model_tid'] = $model->tid;
          $value['make_tid'] = $model->field_make[LANGUAGE_NONE][0]['tid'];
        }
      }
      elseif ($term->vocabulary_machine_name == $field['settings']['allowed_values']['model_vocabulary']['vocabulary']) {
        $value['model_tid'] = $term->tid;
        $value['make_tid'] = $term->field_make[LANGUAGE_NONE][0]['tid'];
      }
      elseif ($term->vocabulary_machine_name == $field['settings']['allowed_values']['make_vocabulary']['vocabulary']) {
        $value['make_tid'] = $term->tid;
      }
    }
  }

  // autocomplete uses a fake element so the values need to be added to the delta and not the element
  array_pop($element['#parents']);

  form_set_value($element, $value, $form_state);
}

/**
 * Implements hook_field_validate().
 *
 * Taxonomy field settings allow for either a single vocabulary ID, multiple
 * vocabulary IDs, or sub-trees of a vocabulary to be specified as allowed
 * values, although only the first of these is supported via the field UI.
 * Confirm that terms entered as values meet at least one of these conditions.
 *
 * Possible error codes:
 * - 'taxonomy_term_illegal_value': The value is not part of the list of allowed values.
 */
function car_reference_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {

  foreach ($items as $delta => $item) {

    $validate = TRUE;

    //validation fails if some random value is input.
    if(!isset($item['make_tid'])){
      $validate = FALSE;
      // If the user hasn't provided an input value, check if that is allowed.
      if (!isset($item['raw_input'])) {
        // Don't force default values on field instance settings form.
        if (empty($entity_type)) {
          $validate = TRUE;
        }
        // Don't force values when field is not required.
        if(!$instance['required']){
          $validate = TRUE;
        }
      }
    }
    if (isset($item['make_tid']) && $term = taxonomy_term_load($item['make_tid'])) {
      $validate = FALSE;

      if(in_array($term->vocabulary_machine_name, $instance['settings']['choose_from'], true)){
        $validate = TRUE;
      }
    }

    if (isset($item['model_tid']) && $term = taxonomy_term_load($item['model_tid'])) {
      $validate = FALSE;

      if(in_array($term->vocabulary_machine_name, $instance['settings']['choose_from'], true)){
        $validate = TRUE;
      }
    }

    if (isset($item['edition_tid']) && $term = taxonomy_term_load($item['edition_tid'])) {
      $validate = FALSE;

      if(in_array($term->vocabulary_machine_name, $instance['settings']['choose_from'], true)){
        $validate = TRUE;
      }
    }

    if (!$validate) {
      $errors[$field['field_name']][$langcode][$delta][] = array(
        'error' => 'taxonomy_term_reference_illegal_value',
        'message' => t('%name: illegal value.', array('%name' => $instance['label'])),
      );
    }
  }

}

/**
 * Implements hook_entity_insert().
 */
function car_reference_entity_insert($entity, $type) {
  if ($type == 'node') {
    car_reference_build_node_index($entity);
  }
}

/**
 * Implements hook_entity_update().
 */
function car_reference_entity_update($entity, $type) {
  if ($type == 'node') {
    car_reference_build_node_index($entity);
  }
}

/**
 * Builds and inserts car reference taxonomy index entries for a given node.
 *
 * The index lists all terms that are related to a given node entity, and is
 * therefore maintained at the entity level.
 *
 * @param $node
 *   The node object.
 */
function car_reference_build_node_index($node) {
  // We maintain a denormalized table of term/node relationships, containing
  // only data for current, published nodes.
  $status = NULL;
  if (variable_get('taxonomy_maintain_index_table', TRUE)) {
    // If a node property is not set in the node object when node_save() is
    // called, the old value from $node->original is used.
    if (!empty($node->original)) {
      $status = (int)(!empty($node->status) || (!isset($node->status) && !empty($node->original->status)));
      $sticky = (int)(!empty($node->sticky) || (!isset($node->sticky) && !empty($node->original->sticky)));
    }
    else {
      $status = (int)(!empty($node->status));
      $sticky = (int)(!empty($node->sticky));
    }
  }
  // We only maintain the taxonomy index for published nodes.
  if ($status) {
    // Collect a unique list of all the term IDs from all node fields.
    $tid_all = array();
    foreach (field_info_instances('node', $node->type) as $instance) {
      $field_name = $instance['field_name'];
      $field = field_info_field($field_name);
      if ($field['module'] == 'car_reference' && $field['storage']['type'] == 'field_sql_storage') {
        // If a field value is not set in the node object when node_save() is
        // called, the old value from $node->original is used.
        if (isset($node->{$field_name})) {
          $items = $node->{$field_name};
        }
        elseif (isset($node->original->{$field_name})) {
          $items = $node->original->{$field_name};
        }
        else {
          continue;
        }
        foreach (field_available_languages('node', $field) as $langcode) {
          if (!empty($items[$langcode])) {
            foreach ($items[$langcode] as $item) {
              $tid_all[$item['make_tid']] = $item['make_tid'];
              if (isset($item['model_tid'])) {
                $tid_all[$item['model_tid']] = $item['model_tid'];
              }
              if (isset($item['edition_tid'])) {
                $tid_all[$item['edition_tid']] = $item['edition_tid'];
              }
            }
          }
        }
      }
    }
    // Insert index entries for all the node's terms.
    if (!empty($tid_all)) {
      $query = db_insert('taxonomy_index')->fields(array('nid', 'tid', 'sticky', 'created'));
      foreach ($tid_all as $tid) {
        $query->values(array(
          'nid' => $node->nid,
          'tid' => $tid,
          'sticky' => $sticky,
          'created' => $node->created,
        ));
      }
      $query->execute();
    }
  }
}


/**
 * Implements hook_token_info().
 */
function car_reference_token_info() {
  $info['tokens']['node']['car_reference_make_name'] = array(
    'name' => t('Car reference make name'),
    'description' => t('Car reference make name.'),
  );
  $info['tokens']['node']['car_reference_make_name_url'] = array(
    'name' => t('Car reference make name for URLs'),
    'description' => t('Car reference make name value for use in URLs.'),
  );
  $info['tokens']['node']['car_reference_make_term_alias'] = array(
    'name' => t('Car reference make taxonomy term URL alias'),
    'description' => t('The make terms URL alias. eg ford'),
  );

  $info['tokens']['node']['car_reference_model_name'] = array(
    'name' => t('Car reference model name'),
    'description' => t('Car reference model name.'),
  );
  $info['tokens']['node']['car_reference_model_name_url'] = array(
    'name' => t('Car reference model name for URLs'),
    'description' => t('Car reference model name value for use in URLs.'),
  );
  $info['tokens']['node']['car_reference_model_term_alias'] = array(
    'name' => t('Car reference model taxonomy term URL alias'),
    'description' => t('The model terms URL alias. eg ford/focus'),
  );

  $info['tokens']['node']['car_reference_edition_name'] = array(
    'name' => t('Car reference edition name'),
    'description' => t('Car reference edition name.'),
  );
  $info['tokens']['node']['car_reference_edition_name_url'] = array(
    'name' => t('Car reference edition name for URLs'),
    'description' => t('Car reference edition name value for use in URLs.'),
  );
  return $info;
}
/**
 * Implements hook_tokens().
 * @param string $type
 * @param array $tokens
 * @param array $data
 * @param array $options
 * @return array $replacements
 */
function car_reference_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];

    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'car_reference_make_name':
        case 'car_reference_make_name_url':
          if (!empty($node->field_primary_car_reference[LANGUAGE_NONE][0]['make_tid'])) {
            $replacements[$original] = car_reference_get_make_name($node->field_primary_car_reference[LANGUAGE_NONE][0]['make_tid']);
          }
          break;
        case 'car_reference_make_term_alias':
          if (!empty($node->field_primary_car_reference[LANGUAGE_NONE][0]['make_tid'])) {
            $replacements[$original] = drupal_lookup_path('alias', 'taxonomy/term/' . $node->field_primary_car_reference[LANGUAGE_NONE][0]['make_tid']);
          }
          break;
        case 'car_reference_model_name':
        case 'car_reference_model_name_url':
          if (!empty($node->field_primary_car_reference[LANGUAGE_NONE][0]['model_tid'])) {
            $replacements[$original] = car_reference_get_model_name($node->field_primary_car_reference[LANGUAGE_NONE][0]['model_tid']);
          }
          break;
        case 'car_reference_model_term_alias':
          if (!empty($node->field_primary_car_reference[LANGUAGE_NONE][0]['model_tid'])) {
            $replacements[$original] = drupal_lookup_path('alias', 'taxonomy/term/' . $node->field_primary_car_reference[LANGUAGE_NONE][0]['model_tid']);
          }
          break;
        case 'car_reference_edition_name':
        case 'car_reference_edition_name_url':
          if (!empty($node->field_primary_car_reference[LANGUAGE_NONE][0]['edition_tid'])) {
            $replacements[$original] = car_reference_get_edition_name($node->field_primary_car_reference[LANGUAGE_NONE][0]['edition_tid']);
          }
          break;


      }

      if (!empty($replacements[$original]) && ($name == 'car_reference_edition_name_url' || $name == 'car_reference_model_name_url' || $name == 'car_reference_make_name_url')) {
        if (!function_exists('pathauto_cleanstring')) {
          module_load_include('inc', 'pathauto');
        }
        $replacements[$original] = pathauto_cleanstring($replacements[$original]);
      }

    }
  }
  return $replacements;
}

/**
 * Returns a model name given a model tid
 * @param string $tid
 */
function car_reference_get_model_name($tid) {
  $query = db_select('field_data_field_short_name', 'mn')->fields('mn', array('field_short_name_value'));
  $query->condition('mn.entity_id', $tid)->condition('mn.entity_type', 'taxonomy_term')->condition('deleted', 0);
  return $query->execute()->fetchField();
}

/**
 * Returns an edition name given an edition tid
 * @param string $tid
 */
function car_reference_get_edition_name($tid) {
  $query = db_select('field_data_field_short_name', 'en')->fields('en', array('field_short_name_value'));
  $query->condition('en.entity_id', $tid)->condition('en.entity_type', 'taxonomy_term')->condition('deleted', 0);
  return $query->execute()->fetchField();
}

/**
 * Returns a make name given a make tid
 * @param string $tid
 */
function car_reference_get_make_name($tid) {
  if ($term = taxonomy_term_load($tid)) {
    return $term->name;
  }
}

/**
 * Returns the key value pairs of the given tids for use in adtags etc.
 *
 * @param array $tids
 */
function car_reference_get_key_value_pairs($tids) {
  $kvp = array();
  $terms = taxonomy_term_load_multiple($tids);
  foreach ($terms as $term) {
    switch ($term->vocabulary_machine_name) {
      case 'make':
      case 'model':
        $kvp[$term->vocabulary_machine_name][] = $term->name;
        break;
      case 'edition':
        $kvp[$term->vocabulary_machine_name][] = $term->name;
        // Get the body style from the edition name
        $field = field_get_items('taxonomy_term', $term, 'field_short_name');
        $kvp['bodystyle'][] = $field[0]['value'];
        break;
    }
  }

  return $kvp;
}
